# taotao
taotao是一个B2C服务平台  
基于SOA架构的项目  
这个项目来源于网上广泛流传的淘淘商城，学习这个项目对我的分布式学习之旅提供了非常大的帮助。
我在这里把它的架构和涉及到的知识点详细介绍一下。
整体架构：

![taotao-architecture][1]





既然是SOA，面向服务的架构，我们不妨从服务层来分析淘淘的架构。
  
**内容服务**   
这里的内容指的是主页显示的内容。  
轮播图，大广告，小广告都是内容。因为内容并不是一成不变的，所以需要将其中变化的内容使用数据库存储，显示的时候再从数据库中查询出来。不过直接查询数据库的话速度非常缓慢并且并发量高时数据库会因为压力过大而崩溃。所以这里就需要使用redis缓存内容信息，理论命中率可以达到80%，将内容信息转化为json字符串存储在redis中，这样服务就可以直接从redis中获取对应的内容，为了保证redis集群的高可用需要配置redis集群。要注意的一点是我们对内容进行了修改，这个时候就要及时更新redis缓存等信息，这应该由我们的内容服务来完成。  

**详情页**用来展示商品的详细信息，需要调用商品信息服务。至于商品类别可能是一个大的类别（比如图书，数码产品），而大的类别下会有小的类别，这种商品类别之间的信息被存储在商品类别表中中。  
  
**商品服务**提供了商品信息的服务，主要可以体现为商品的增删改查，商品类别的增删改查。  
什么样的应用会调用这个服务呢。商品的详情页，购物车，后台的管理系统。商品的详情页，购物车用的是查的功能，而管理系统则可以增删改。商品类别服务在根据类别来筛选商品时使用。  

创建一个**订单**需要做些什么？  
一个订单相关联的表有哪些？  
订单信息表：创建时间，消费金额，邮费等等。  
订单明细表：订单中包含的商品信息（商品金额，商品数量等）。  
订单物流表：订单的物流信息。  
订单服务提供创建订单，删除订单，改变订单状态等功能。订单系统通过用户输入的订单相关信息调用订单服务来完成添加订单的工作。  
订单号是需要**全局唯一**的，简单起见可以使用redis的incr命令来生成。  

**单点登录系统**：单点登录系统需要提供登录和注册的页面，并且需要解决分布式环境下Session共享的问题。并且如果其它系统想要获取登录信息，或者进行登录操作，都应该通过单点登录系统暴露的url进行相应的操作。  

**搜索**也是至关重要的一个功能，用户需要通过搜索引擎来获得感兴趣的信息。所以taotao使用了一个单独的搜索系统，并部署了搜索服务，搜索服务提供将商品信息导入索引库的功能。搜索服务查询数据库获取相关的商品信息，再根据solr中配置的属性域生成对应的文档，再将文档导入索引库中。如果要使用搜索功能，只要生成solr标准的查询字符串再通过SSO系统调用sso服务就能得到搜索结果。  

这里再总结一下其中的重要技术点：  

**使用redis作为缓存**  
缓存系统是保证分布式系统高性能和高可用至关重要的一环。redis作为缓存的一大优势就是数据类型丰富，拥有string和hash类型的值，其中hash类型特别适合用于存储对象，比如用户的session信息，购物车信息。  部分热门的商品详情页也可以使用redis缓存，或者设置过期时间，每次有访问这个页面的请求时都会重置过期时间，这样访问频率高的总能留在redis中。  

**页面静态化**  
如果我们的页面都是静态页面，那么完全可以独立使用nginx部署，nginx能支持的并发数在tomcat的百倍以上，对于静态文件的处理速度速度也极高。如果我们能把动态网页静态化，就能极大的提高性能。taotao中的静态化主要针对商品详情页，使用一个freemarker模板生成对应的商品详情页静态页面  


**使用消息队列进行解耦**  
如果我们添加了一个商品之后，那么我们需要在商品库中添加文档，我们需要生成其静态页面。这样的操作都在商品服务中完成吗？如果这样做的话服务与服务之间就产生了依赖关系，一个服务的不可用会导致其他服务的不可用。这里就需要引进消息中间件，将商品添加作为一个主题，搜索系统（或搜索服务）都订阅这个主题。一旦有商品添加时间，商品服务便会向商品  


**Session共享**  
使用redis保存Session，并设置过期时间，SSO系统生成一个token，将token和Session为键值对放在redis中，Session的过期时间可以通过设置key的过期时间来确定。客户端每次访问都会带上这个token，应用系统拿到这个token向SSO系统请求Session信息，SSO系统从sso服务中获取用户的信息，需要注意，需要设置cookie的domainName，这样拥有同一个父域名（如taotao.com）的域之间才能共享这个token。    
具体实现：  
taotao中的应用可以调用SSO系服务进行用户登录状态的查询，如果没有查询到说明登录已经过期，则要求用户进行登录，登录成功则在服务层生成一个UUID，从数据库查询用户相关信息，并将UUID和Session保存在redis中。等到下一次来自同一域名下的应用请求用户登录信息时，就会能通过token从redis中取出Session（无需登录），这样就实现了Session共享和单点登录。  
注：更新cookie在sso-web中进行；生成token，获取redis中的session信息在sso-service中进行。  
所有需要登录的页面，都应该设置拦截器，判断redis中有无用户的登录信息，如果没有则需要重定向到登录页面，同时将当前页面的Url作为回调Url  

**购物车要如何实现？**  
1. 本地cookie实现，将购物车信息保存到本地的cookie中，浏览器每次访问时都会带上这个cookie。有相应的操作购物车的动作时，服务端修改cookie，并重新写会浏览器中。  
优点：实现简单，不占用服务器的存储资源。  
缺点：不能实现跨设备共享，并且有长度限制，会占用网络传输带宽。  
2. redis实现  
使用Hash类型的值来存储购物车信息。  
hash的field用来存储商品id和商品信息的键值对。（原本商品的num字段对应的是库存值，这里可以用来表示商品数量）  
用户未登录的时候写cookie，用户登录后，访问购物车列表时，把cookie中的数据同步到redis，删除cookie中的数据。  




[1]:http://blog.jesonlee.top/static/user/image/taotao-architecture.png
